"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.webSocketsPlugin = exports.webSocketScript = void 0;
const parse5_1 = require("parse5");
const dom5_1 = require("../dom5");
const WebSocketsManager_1 = require("./WebSocketsManager");
exports.webSocketScript = `<!-- injected by web-dev-server -->
<script type="module" src="${WebSocketsManager_1.NAME_WEB_SOCKET_IMPORT}"></script>`;
function webSocketsPlugin() {
    return {
        name: 'web-sockets',
        serve(context) {
            if (context.path === WebSocketsManager_1.NAME_WEB_SOCKET_IMPORT) {
                return `export const webSocket = ('WebSocket' in window) ? new WebSocket(\`ws\${location.protocol === 'https:' ? 's': ''}://\${location.host}\`) : null;
export const webSocketOpened = new Promise((resolve) => {
  if (!webSocket) {
    resolve();
  } else {
    webSocket.addEventListener('open', () => {
      resolve();
    });
  }
});

let messageId = 0;
function nextMessageId() {
  if (messageId >= Number.MAX_SAFE_INTEGER) {
    messageId = 0;
  }
  messageId += 1;
  return messageId;
}

export async function sendMessage(message) {
  if (!message.type) {
    throw new Error('Missing message type');
  }
  await webSocketOpened;
  webSocket.send(JSON.stringify(message));
}

// sends a websocket message and expects a response from the server
export function sendMessageWaitForResponse(message) {
  return new Promise(async (resolve, reject) => {
    const id = nextMessageId();

    function onResponse(e) {
      const message = JSON.parse(e.data);
      if (message.type === 'message-response' && message.id === id) {
        webSocket.removeEventListener('message', onResponse);
        if (message.error) {
          reject(new Error(message.error))
        } else {
          resolve(message.response);
        }
      }
    }

    webSocket.addEventListener('message', onResponse);

    const timeoutId = setTimeout(() => {
      webSocket.removeEventListener('message', onResponse);
      reject(new Error(\`Did not receive a server response for message with type \${message.type} within 20000ms\`))
    }, 20000);

    sendMessage({ ...message, id });
  });
}

if (webSocket) {
  webSocket.addEventListener('message', async (e) => {
    try {
      const message = JSON.parse(e.data);
      if (message.type === 'import') {
        const module = await import(message.data.importPath);
        if (typeof module.default === 'function') {
          module.default(...(message.data.args || []));
        }
        return;
      } 
    } catch (error) {
      console.error('[Web Dev Server] Error while handling websocket message.');
      console.error(error);
    }
  });
}`;
            }
        },
        async transform(context) {
            if (context.response.is('html')) {
                const documentAst = parse5_1.parse(context.body, { sourceCodeLocationInfo: true });
                const htmlNode = dom5_1.query(documentAst, dom5_1.predicates.hasTagName('html'));
                const bodyNode = dom5_1.query(documentAst, dom5_1.predicates.hasTagName('body'));
                if (!(htmlNode === null || htmlNode === void 0 ? void 0 : htmlNode.sourceCodeLocation) || !(bodyNode === null || bodyNode === void 0 ? void 0 : bodyNode.sourceCodeLocation)) {
                    // if html or body tag does not have a source code location it was generated
                    return;
                }
                const { startOffset } = bodyNode.sourceCodeLocation.endTag;
                const start = context.body.substring(0, startOffset);
                const end = context.body.substring(startOffset);
                return `${start}\n\n${exports.webSocketScript}\n\n${end}`;
            }
        },
    };
}
exports.webSocketsPlugin = webSocketsPlugin;
//# sourceMappingURL=webSocketsPlugin.js.map